// Derived from Go's src/crypto/hkdf/hkdf.go and
// src/crypto/internal/fips140/hkdf/hkdf.go, which carry this notice:
// Copyright 2024 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package hkdf implements the HMAC-based Extract-and-Expand Key Derivation
// Function (HKDF) as defined in RFC 5869.
//
// HKDF is a cryptographic key derivation function (KDF) with the goal of
// expanding limited input keying material into one or more cryptographically
// strong secret keys.

#include <u.h>
#include <libc.h>
#include <libsec.h>

// hkdfExtract generates a pseudorandom key for use with hkdfExpand from an input
// secret and an optional independent salt.
//
// Only use this function if you need to reuse the extracted key with multiple
// Expand invocations and different context values. Most common scenarios,
// including the generation of multiple keys, should use hkdfKey instead.
void
hkdfExtract(uchar *out, DigestState*(*x)(uchar*, ulong, uchar*, DigestState*), int xlen,
uchar *secret, int nsecret, uchar *salt, int nsalt)
{
	uchar *s, zerosalt[Maxdlen] = { 0 };

	assert(xlen <= Maxdlen);

	s = salt;
	if(s == nil) {
		s = zerosalt;
		nsalt = xlen;
	}

	hmac_x(secret, nsecret, s, nsalt, out, nil, x, xlen);
}

#define MIN(a, b)     ((a) < (b)? (a): (b))

// hkdfExpand derives a key from the given hash, key, and optional context info,
// returning a byte array in out of length keylen that can be used as cryptographic key.
// The extraction step is skipped.
//
// The key should have been generated by hkdfExtract, or be a uniformly
// random or pseudorandom cryptographically strong key. See RFC 5869, Section
// 3.3. Most common scenarios will want to use hkdfKey instead.
int
hkdfExpand(uchar *out, DigestState*(*x)(uchar*, ulong, uchar*, DigestState*), int xlen,
uchar *prk, int nprk, uchar *info, int ninfo, int keylen)
{
	u8int counter = 0;
	uchar buf[Maxdlen] = { 0 };
	int olen = 0, blen = 0, remain;
	DigestState *s;

	assert(xlen <= Maxdlen);

	if(keylen > xlen * 255) {
		werrstr("hkdf: requested key length too large");
		return -1;
	}

	if(info == nil)
		ninfo = 0;

	while(olen < keylen) {
		counter++;
		assert(counter != 0);
		s = hmac_x(buf, blen, prk, nprk, nil, nil, x, xlen);
		hmac_x(info, ninfo, prk, nprk, nil, s, x, xlen);
		hmac_x(&counter, 1, prk, nprk, buf, s, x, xlen);
		blen = xlen;
		remain  = keylen - olen;
		remain = MIN(remain, blen);
		memmove(out + olen, buf, remain);
		olen += remain;
	}

	return 1;
}

// hkdfKey derives a key from the given hash, secret, salt and context info,
// returning a byte array in out of length keylen that can be used as cryptographic key.
// Salt and info can be nil.
int
hkdfKey(uchar *out, DigestState*(*x)(uchar*, ulong, uchar*, DigestState*),int xlen,
uchar* secret, int nsecret, uchar* salt, int nsalt, uchar *info, int ninfo, int keylen)
{
	uchar prk[Maxdlen];

	assert(xlen <= Maxdlen);

	if(keylen > xlen * 255) {
		werrstr("hkdf: requested key length too large");
		return -1;
	}

	hkdfExtract(prk, x, xlen, secret, nsecret, salt, nsalt);
	hkdfExpand(out, x, xlen, prk, xlen, info, ninfo, keylen);

	return 1;
}
