<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=utf8">
<title>A Manual for the Plan 9 assembler</title>
</meta>
</head>
<body>
<p style="margin-top: 0; margin-bottom: 0.50in"></p>
<p style="margin-top: 0; margin-bottom: 0.21in"></p>

<p style="line-height: 1.4em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: center;">
<span style="font-size: 12pt"><b>A Manual for the Plan 9 assembler</b></span></p>
<p style="margin-top: 0; margin-bottom: 0.21in"></p>

<p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.4em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: center;">
<span style="font-size: 10pt"><i>Rob&nbsp;Pike</i></span></p>
<p style="line-height: 1.4em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: center;">
<span style="font-size: 10pt"><i>rob@plan9.bell-labs.com</i></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="margin-top: 0; margin-bottom: 0.33in"></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="margin-top: 0; margin-bottom: 0.50in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>Machines
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">There is an assembler for each of the MIPS, SPARC (retired), Intel 386, AMD64,
Power PC, 64-bit Power PC, ARM, ARM64, and RISC-V.
The 68020 assembler,
</span><span style="font-size: 10pt"><tt>2a</tt></span><span style="font-size: 10pt">
(no longer distributed),
is the oldest and in many ways the prototype.
The assemblers are really just variations of a single program:
they share many properties such as left-to-right assignment order for
instruction operands and the synthesis of macro instructions
such as
</span><span style="font-size: 10pt"><tt>MOV</tt></span><span style="font-size: 10pt">
to hide the peculiarities of the load and store structure of the machines.
To keep things concrete, the first part of this manual is
specifically about the 68020.
At the end is a description of the differences among
the other assemblers.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The document, &lsquo;&lsquo;How to Use the Plan 9 C Compiler&rsquo;&rsquo;, by Rob Pike,
is a prerequisite for this manual.
</span></p><p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>Registers
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">All pre-defined symbols in the assembler are upper-case.
Data registers are
</span><span style="font-size: 10pt"><tt>R0</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>R7</tt></span><span style="font-size: 10pt">;
address registers are
</span><span style="font-size: 10pt"><tt>A0</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>A7</tt></span><span style="font-size: 10pt">;
floating-point registers are
</span><span style="font-size: 10pt"><tt>F0</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>F7</tt></span><span style="font-size: 10pt">.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">A pointer in
</span><span style="font-size: 10pt"><tt>A6</tt></span><span style="font-size: 10pt">
is used by the C compiler to point to data, enabling short addresses to
be used more often.
The value of
</span><span style="font-size: 10pt"><tt>A6</tt></span><span style="font-size: 10pt">
is constant and must be set during C program initialization
to the address of the externally-defined symbol
</span><span style="font-size: 10pt"><tt>a6base</tt></span><span style="font-size: 10pt">.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The following hardware registers are defined in the assembler; their
meaning should be obvious given a 68020 manual:
</span><span style="font-size: 10pt"><tt>CAAR</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>CACR</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>CCR</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>DFC</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>ISP</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MSP</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>SFC</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>SR</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>USP</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>VBR</tt></span><span style="font-size: 10pt">.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The assembler also defines several pseudo-registers that
manipulate the stack:
</span><span style="font-size: 10pt"><tt>FP</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>SP</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>TOS</tt></span><span style="font-size: 10pt">.
</span><span style="font-size: 10pt"><tt>FP</tt></span><span style="font-size: 10pt">
is the frame pointer, so
</span><span style="font-size: 10pt"><tt>0(FP)</tt></span><span style="font-size: 10pt">
is the first argument,
</span><span style="font-size: 10pt"><tt>4(FP)</tt></span><span style="font-size: 10pt">
is the second, and so on.
</span><span style="font-size: 10pt"><tt>SP</tt></span><span style="font-size: 10pt">
is the local stack pointer, where automatic variables are held
(SP is a pseudo-register on the 68020);
</span><span style="font-size: 10pt"><tt>0(SP)</tt></span><span style="font-size: 10pt">
is the first automatic, and so on as with
</span><span style="font-size: 10pt"><tt>FP</tt></span><span style="font-size: 10pt">.
Finally,
</span><span style="font-size: 10pt"><tt>TOS</tt></span><span style="font-size: 10pt">
is the top-of-stack register, used for pushing parameters to procedures,
saving temporary values, and so on.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The assembler and loader track these pseudo-registers so
the above statements are true regardless of what has been
pushed on the hardware stack, pointed to by
</span><span style="font-size: 10pt"><tt>A7</tt></span><span style="font-size: 10pt">.
The name
</span><span style="font-size: 10pt"><tt>A7</tt></span><span style="font-size: 10pt">
refers to the hardware stack pointer, but beware of mixed use of
</span><span style="font-size: 10pt"><tt>A7</tt></span><span style="font-size: 10pt">
and the above stack-related pseudo-registers, which will cause trouble.
Note, too, that the
</span><span style="font-size: 10pt"><tt>PEA</tt></span><span style="font-size: 10pt">
instruction is observed by the loader to
alter SP and thus will insert a corresponding pop before all returns.
The assembler accepts a label-like name to be attached to
</span><span style="font-size: 10pt"><tt>FP</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>SP</tt></span><span style="font-size: 10pt">
uses, such as
</span><span style="font-size: 10pt"><tt>p+0(FP)</tt></span><span style="font-size: 10pt">,
to help document that
</span><span style="font-size: 10pt"><tt>p</tt></span><span style="font-size: 10pt">
is the first argument to a routine.
The name goes in the symbol table but has no significance to the result
of the program.
</span></p><p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>Referring to data
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">All external references must be made relative to some pseudo-register,
either
</span><span style="font-size: 10pt"><tt>PC</tt></span><span style="font-size: 10pt">
(the virtual program counter) or
</span><span style="font-size: 10pt"><tt>SB</tt></span><span style="font-size: 10pt">
(the &lsquo;&lsquo;static base&rsquo;&rsquo; register).
</span><span style="font-size: 10pt"><tt>PC</tt></span><span style="font-size: 10pt">
counts instructions, not bytes of data.
For example, to branch to the second following instruction, that is,
to skip one instruction, one may write
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;BRA&nbsp;2(PC)</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Labels are also allowed, as in
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;BRA&nbsp;return</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;NOP</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>return:</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;RTS</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">When using labels, there is no
</span><span style="font-size: 10pt"><tt>(PC)</tt></span><span style="font-size: 10pt">
annotation.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The pseudo-register
</span><span style="font-size: 10pt"><tt>SB</tt></span><span style="font-size: 10pt">
refers to the beginning of the address space of the program.
Thus, references to global data and procedures are written as
offsets to
</span><span style="font-size: 10pt"><tt>SB</tt></span><span style="font-size: 10pt">,
as in
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVL&nbsp;&nbsp;&nbsp;&nbsp;$array(SB),&nbsp;TOS</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">to push the address of a global array on the stack, or
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVL&nbsp;&nbsp;&nbsp;&nbsp;array+4(SB),&nbsp;TOS</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">to push the second (4-byte) element of the array.
Note the use of an offset; the complete list of addressing modes is given below.
Similarly, subroutine calls must use
</span><span style="font-size: 10pt"><tt>SB</tt></span><span style="font-size: 10pt">:
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;BSR&nbsp;exit(SB)</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">File-static variables have syntax
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;local&lt;&gt;+4(SB)</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The
</span><span style="font-size: 10pt"><tt>&lt;&gt;</tt></span><span style="font-size: 10pt">
will be filled in at load time by a unique integer.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">When a program starts, it must execute
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVL&nbsp;&nbsp;&nbsp;&nbsp;$a6base(SB),&nbsp;A6</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">before accessing any global data.
(On machines such as the MIPS and SPARC that cannot load a register
in a single instruction, constants are loaded through the static base
register.  The loader recognizes code that initializes the static
base register and treats it specially.  You must be careful, however,
not to load large constants on such machines when the static base
register is not set up, such as early in interrupt routines.)
</span></p><p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>Expressions
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Expressions are mostly what one might expect.
Where an offset or a constant is expected,
a primary expression with unary operators is allowed.
A general C constant expression is allowed in parentheses.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Source files are preprocessed exactly as in the C compiler, so
</span><span style="font-size: 10pt"><tt>#define</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>#include</tt></span><span style="font-size: 10pt">
work.
</span></p><p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>Addressing modes
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The simple addressing modes are shared by all the assemblers.
Here, for completeness, follows a table of all the 68020 addressing modes,
since that machine has the richest set.
In the table,
</span><span style="font-size: 10pt"><tt>o</tt></span><span style="font-size: 10pt">
is an offset, which if zero may be elided, and
</span><span style="font-size: 10pt"><tt>d</tt></span><span style="font-size: 10pt">
is a displacement, which is a constant between -128 and 127 inclusive.
Many of the modes listed have the same name;
scrutiny of the format will show what default is being applied.
For instance, indexed mode with no address register supplied operates
as though a zero-valued register were used.
For "offset" read "displacement."
For "</span><span style="font-size: 10pt"><tt>.s</tt></span><span style="font-size: 10pt">" read one of
</span><span style="font-size: 10pt"><tt>.L</tt></span><span style="font-size: 10pt">,
or
</span><span style="font-size: 10pt"><tt>.W</tt></span><span style="font-size: 10pt">
followed by
</span><span style="font-size: 10pt"><tt>*1</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>*2</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>*4</tt></span><span style="font-size: 10pt">,
or
</span><span style="font-size: 10pt"><tt>*8</tt></span><span style="font-size: 10pt">
to indicate the size and scaling of the data.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<center><img src="asm0.png"></center>
</center>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>Laying down data
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Placing data in the instruction stream, say for interrupt vectors, is easy:
the pseudo-instructions
</span><span style="font-size: 10pt"><tt>LONG</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>WORD</tt></span><span style="font-size: 10pt">
(but not
</span><span style="font-size: 10pt"><tt>BYTE</tt></span><span style="font-size: 10pt">)
lay down the value of their single argument, of the appropriate size,
as if it were an instruction:
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;LONG&nbsp;&nbsp;&nbsp;&nbsp;$12345</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">places the long 12345 (base 10)
in the instruction stream.
(On most machines,
the only such operator is
</span><span style="font-size: 10pt"><tt>WORD</tt></span><span style="font-size: 10pt">
and it lays down 32-bit quantities.
The 386 has all three:
</span><span style="font-size: 10pt"><tt>LONG</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>WORD</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>BYTE</tt></span><span style="font-size: 10pt">.
The AMD64 adds
</span><span style="font-size: 10pt"><tt>QUAD</tt></span><span style="font-size: 10pt">
to that for 64-bit values.
The 960 has only one,
</span><span style="font-size: 10pt"><tt>LONG</tt></span><span style="font-size: 10pt">.)
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Placing information in the data section is more painful.
The pseudo-instruction
</span><span style="font-size: 10pt"><tt>DATA</tt></span><span style="font-size: 10pt">
does the work, given two arguments: an address at which to place the item,
including its size,
and the value to place there.  For example, to define a character array
</span><span style="font-size: 10pt"><tt>array</tt></span><span style="font-size: 10pt">
containing the characters
</span><span style="font-size: 10pt"><tt>abc</tt></span><span style="font-size: 10pt">
and a terminating null:
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;DATA&nbsp;&nbsp;&nbsp;&nbsp;array+0(SB)/1,&nbsp;$&rsquo;a&rsquo;</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;DATA&nbsp;&nbsp;&nbsp;&nbsp;array+1(SB)/1,&nbsp;$&rsquo;b&rsquo;</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;DATA&nbsp;&nbsp;&nbsp;&nbsp;array+2(SB)/1,&nbsp;$&rsquo;c&rsquo;</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;GLOBL&nbsp;&nbsp;&nbsp;array(SB),&nbsp;$4</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">or
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;DATA&nbsp;&nbsp;&nbsp;&nbsp;array+0(SB)/4,&nbsp;$"abc\z"</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;GLOBL&nbsp;&nbsp;&nbsp;array(SB),&nbsp;$4</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The
</span><span style="font-size: 10pt"><tt>/1</tt></span><span style="font-size: 10pt">
defines the number of bytes to define,
</span><span style="font-size: 10pt"><tt>GLOBL</tt></span><span style="font-size: 10pt">
makes the symbol global, and the
</span><span style="font-size: 10pt"><tt>$4</tt></span><span style="font-size: 10pt">
says how many bytes the symbol occupies.
Uninitialized data is zeroed automatically.
The character
</span><span style="font-size: 10pt"><tt>\z</tt></span><span style="font-size: 10pt">
is equivalent to the C
</span><span style="font-size: 10pt"><tt>\0.</tt></span><span style="font-size: 10pt">
The string in a
</span><span style="font-size: 10pt"><tt>DATA</tt></span><span style="font-size: 10pt">
statement may contain a maximum of eight bytes;
build larger strings piecewise.
Two pseudo-instructions,
</span><span style="font-size: 10pt"><tt>DYNT</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>INIT</tt></span><span style="font-size: 10pt">,
allow the (obsolete) Alef compilers to build dynamic type information during the load
phase.
The
</span><span style="font-size: 10pt"><tt>DYNT</tt></span><span style="font-size: 10pt">
pseudo-instruction has two forms:
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;DYNT&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;ALEF_SI_5+0(SB)</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;DYNT&nbsp;&nbsp;&nbsp;&nbsp;ALEF_AS+0(SB),&nbsp;ALEF_SI_5+0(SB)</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">In the first form,
</span><span style="font-size: 10pt"><tt>DYNT</tt></span><span style="font-size: 10pt">
defines the symbol to be a small unique integer constant, chosen by the loader,
which is some multiple of the word size.  In the second form,
</span><span style="font-size: 10pt"><tt>DYNT</tt></span><span style="font-size: 10pt">
defines the second symbol in the same way,
places the address of the most recently
defined text symbol in the array specified by the first symbol at the
index defined by the value of the second symbol,
and then adjusts the size of the array accordingly.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The
</span><span style="font-size: 10pt"><tt>INIT</tt></span><span style="font-size: 10pt">
pseudo-instruction takes the same parameters as a
</span><span style="font-size: 10pt"><tt>DATA</tt></span><span style="font-size: 10pt">
statement.  Its symbol is used as the base of an array and the
data item is installed in the array at the offset specified by the most recent
</span><span style="font-size: 10pt"><tt>DYNT</tt></span><span style="font-size: 10pt">
pseudo-instruction.
The size of the array is adjusted accordingly.
The
</span><span style="font-size: 10pt"><tt>DYNT</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>INIT</tt></span><span style="font-size: 10pt">
pseudo-instructions are not implemented on the 68020.
</span></p><p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>Defining a procedure
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Entry points are defined by the pseudo-operation
</span><span style="font-size: 10pt"><tt>TEXT</tt></span><span style="font-size: 10pt">,
which takes as arguments the name of the procedure (including the ubiquitous
</span><span style="font-size: 10pt"><tt>(SB)</tt></span><span style="font-size: 10pt">)
and the number of bytes of automatic storage to pre-allocate on the stack,
which will usually be zero when writing assembly language programs.
On machines with a link register, such as the MIPS and SPARC,
the special value -4 instructs the loader to generate no PC save
and restore instructions, even if the function is not a leaf.
Here is a complete procedure that returns the sum
of its two arguments:
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>TEXT&nbsp;&nbsp;&nbsp;&nbsp;sum(SB),&nbsp;$0</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVL&nbsp;&nbsp;&nbsp;&nbsp;arg1+0(FP),&nbsp;R0</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;ADDL&nbsp;&nbsp;&nbsp;&nbsp;arg2+4(FP),&nbsp;R0</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;RTS</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">An optional middle argument
to the
</span><span style="font-size: 10pt"><tt>TEXT</tt></span><span style="font-size: 10pt">
pseudo-op is a bit field of options to the loader.
Setting the 1 bit suspends profiling the function
when profiling is enabled for the rest of
the program, when in user mode.
For example,
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>TEXT&nbsp;&nbsp;&nbsp;&nbsp;sum(SB),&nbsp;1,&nbsp;$0</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVL&nbsp;&nbsp;&nbsp;&nbsp;arg1+0(FP),&nbsp;R0</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;ADDL&nbsp;&nbsp;&nbsp;&nbsp;arg2+4(FP),&nbsp;R0</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;RTS</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">will not be profiled; the first version above would be.
Subroutines with peculiar state, such as system call routines,
should not be profiled.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Setting the 2 bit allows multiple definitions of the same
</span><span style="font-size: 10pt"><tt>TEXT</tt></span><span style="font-size: 10pt">
symbol in a program; the loader will place only one such function in the image.
It was emitted only by the Alef compilers.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Subroutines to be called from C should place their result in
</span><span style="font-size: 10pt"><tt>R0</tt></span><span style="font-size: 10pt">,
even if it is an address.
Floating point values are returned in
</span><span style="font-size: 10pt"><tt>F0</tt></span><span style="font-size: 10pt">.
Functions that return a structure to a C program
receive as their first argument the address of the location to
store the result;
</span><span style="font-size: 10pt"><tt>R0</tt></span><span style="font-size: 10pt">
is unused in the calling protocol for such procedures.
A subroutine is responsible for saving its own registers,
and therefore is free to use any registers without saving them (&lsquo;&lsquo;caller saves&rsquo;&rsquo;).
</span><span style="font-size: 10pt"><tt>A6</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>A7</tt></span><span style="font-size: 10pt">
are the exceptions as described above.
</span></p><p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>When in doubt
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">If you get confused, try using the
</span><span style="font-size: 10pt"><tt>-S</tt></span><span style="font-size: 10pt">
option to
</span><span style="font-size: 10pt"><tt>2c</tt></span><span style="font-size: 10pt">
and compiling a sample program.
The standard output is valid input to the assembler.
</span></p><p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>Instructions
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The instruction set of the assembler is not identical to that
of the machine.
It is chosen to match what the compiler generates, augmented
slightly by specific needs of the operating system.
For example,
</span><span style="font-size: 10pt"><tt>2a</tt></span><span style="font-size: 10pt">
does not distinguish between the various forms of
</span><span style="font-size: 10pt"><tt>MOVE</tt></span><span style="font-size: 10pt">
instruction: move quick, move address, etc.  Instead the context
does the job.  For example,
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVL&nbsp;&nbsp;&nbsp;&nbsp;$1,&nbsp;R1</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVL&nbsp;&nbsp;&nbsp;&nbsp;A0,&nbsp;R2</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVW&nbsp;&nbsp;&nbsp;&nbsp;SR,&nbsp;R3</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">generates official
</span><span style="font-size: 10pt"><tt>MOVEQ</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MOVEA</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>MOVESR</tt></span><span style="font-size: 10pt">
instructions.
A number of instructions do not have the syntax necessary to specify
their entire capabilities.  Notable examples are the bitfield
instructions, the
multiply and divide instructions, etc.
For a complete set of generated instruction names (in
</span><span style="font-size: 10pt"><tt>2a</tt></span><span style="font-size: 10pt">
notation, not Motorola&rsquo;s) see the file
</span><span style="font-size: 10pt"><tt>/sys/src/cmd/2c/2.out.h</tt></span><span style="font-size: 10pt">.
Despite its name, this file contains an enumeration of the
instructions that appear in the intermediate files generated
by the compiler, which correspond exactly to lines of assembly language.
</span></p><p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>Laying down instructions
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The loader modifies the code produced by the assembler and compiler.
It folds branches,
copies short sequences of code to eliminate branches,
and discards unreachable code.
The first instruction of every function is assumed to be reachable.
The pseudo-instruction
</span><span style="font-size: 10pt"><tt>NOP</tt></span><span style="font-size: 10pt">,
which you may see in compiler output,
means no instruction at all, rather than an instruction that does nothing.
The loader discards all
</span><span style="font-size: 10pt"><tt>NOP</tt></span><span style="font-size: 10pt">&rsquo;s.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">To generate a true
</span><span style="font-size: 10pt"><tt>NOP</tt></span><span style="font-size: 10pt">
instruction, or any other instruction not known to the assembler, use a
</span><span style="font-size: 10pt"><tt>WORD</tt></span><span style="font-size: 10pt">
pseudo-instruction.
Such instructions on RISCs are not scheduled by the loader and must have
their delay slots filled manually.
</span></p><p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>MIPS
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The registers are only addressed by number:
</span><span style="font-size: 10pt"><tt>R0</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>R31</tt></span><span style="font-size: 10pt">.
</span><span style="font-size: 10pt"><tt>R29</tt></span><span style="font-size: 10pt">
is the stack pointer;
</span><span style="font-size: 10pt"><tt>R30</tt></span><span style="font-size: 10pt">
is used as the static base pointer, the analogue of
</span><span style="font-size: 10pt"><tt>A6</tt></span><span style="font-size: 10pt">
on the 68020.
Its value is the address of the global symbol
</span><span style="font-size: 10pt"><tt>setR30(SB)</tt></span><span style="font-size: 10pt">.
The register holding returned values from subroutines is
</span><span style="font-size: 10pt"><tt>R1</tt></span><span style="font-size: 10pt">.
When a function is called, space for the first argument
is reserved at
</span><span style="font-size: 10pt"><tt>0(FP)</tt></span><span style="font-size: 10pt">
but in C (not Alef) the value is passed in
</span><span style="font-size: 10pt"><tt>R1</tt></span><span style="font-size: 10pt">
instead.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The loader uses
</span><span style="font-size: 10pt"><tt>R28</tt></span><span style="font-size: 10pt">
as a temporary.  The system uses
</span><span style="font-size: 10pt"><tt>R26</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>R27</tt></span><span style="font-size: 10pt">
as interrupt-time temporaries.  Therefore none of these registers
should be used in user code.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The control registers are not known to the assembler.
Instead they are numbered registers
</span><span style="font-size: 10pt"><tt>M0</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>M1</tt></span><span style="font-size: 10pt">,
etc.
Use this trick to access, say,
</span><span style="font-size: 10pt"><tt>STATUS</tt></span><span style="font-size: 10pt">:
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>#define&nbsp;STATUS&nbsp;&nbsp;12</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVW&nbsp;&nbsp;&nbsp;&nbsp;M(STATUS),&nbsp;R1</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Floating point registers are called
</span><span style="font-size: 10pt"><tt>F0</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>F31</tt></span><span style="font-size: 10pt">.
By convention,
</span><span style="font-size: 10pt"><tt>F24</tt></span><span style="font-size: 10pt">
must be initialized to the value 0.0,
</span><span style="font-size: 10pt"><tt>F26</tt></span><span style="font-size: 10pt">
to 0.5,
</span><span style="font-size: 10pt"><tt>F28</tt></span><span style="font-size: 10pt">
to 1.0, and
</span><span style="font-size: 10pt"><tt>F30</tt></span><span style="font-size: 10pt">
to 2.0;
this is done by the operating system.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The instructions and their syntax are different from those of the manufacturer&rsquo;s
manual.
There are no
</span><span style="font-size: 10pt"><tt>lui</tt></span><span style="font-size: 10pt">
and kin; instead there are
</span><span style="font-size: 10pt"><tt>MOVW</tt></span><span style="font-size: 10pt">
(move word),
</span><span style="font-size: 10pt"><tt>MOVH</tt></span><span style="font-size: 10pt">
(move halfword),
and
</span><span style="font-size: 10pt"><tt>MOVB</tt></span><span style="font-size: 10pt">
(move byte) pseudo-instructions.  If the operand is unsigned, the instructions
are
</span><span style="font-size: 10pt"><tt>MOVHU</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>MOVBU</tt></span><span style="font-size: 10pt">.
The order of operands is from left to right in dataflow order, just as
on the 68020 but not as in MIPS documentation.
This means that the
</span><span style="font-size: 10pt"><tt>Bcond</tt></span><span style="font-size: 10pt">
instructions are reversed with respect to the book; for example, a
</span><span style="font-size: 10pt"><tt>va</tt></span><span style="font-size: 10pt">
</span><span style="font-size: 10pt"><tt>BGTZ</tt></span><span style="font-size: 10pt">
generates a MIPS
</span><span style="font-size: 10pt"><tt>bltz</tt></span><span style="font-size: 10pt">
instruction.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The assembler is for the R2000, R3000, and most of the R4000 and R6000 architectures.
It understands the 64-bit instructions
</span><span style="font-size: 10pt"><tt>MOVV</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MOVVL</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>ADDV</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>ADDVU</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>SUBV</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>SUBVU</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MULV</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MULVU</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>DIVV</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>DIVVU</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>SLLV</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>SRLV</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>SRAV</tt></span><span style="font-size: 10pt">.
The assembler does not have any cache, load-linked, or store-conditional instructions.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Some assembler instructions are expanded into multiple instructions by the loader.
For example the loader may convert the load of a 32 bit constant into an
</span><span style="font-size: 10pt"><tt>lui</tt></span><span style="font-size: 10pt">
followed by an
</span><span style="font-size: 10pt"><tt>ori</tt></span><span style="font-size: 10pt">.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Assembler instructions should be laid out as if there
were no load, branch, or floating point compare delay slots;
the loader will rearrange&mdash;</span><span style="font-size: 10pt"><i>schedule</i></span><span style="font-size: 10pt">&mdash;the instructions
to guarantee correctness and improve performance.
The only exception is that the correct scheduling of instructions
that use control registers varies from model to model of machine
(and is often undocumented) so you should schedule such instructions
by hand to guarantee correct behavior.
The loader generates
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;NOR&nbsp;R0,&nbsp;R0,&nbsp;R0</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">when it needs a true no-op instruction.
Use exactly this instruction when scheduling code manually;
the loader recognizes it and schedules the code before it and after it independently.  Also,
</span><span style="font-size: 10pt"><tt>WORD</tt></span><span style="font-size: 10pt">
pseudo-ops are scheduled like no-ops.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The
</span><span style="font-size: 10pt"><tt>NOSCHED</tt></span><span style="font-size: 10pt">
pseudo-op disables instruction scheduling
(scheduling is enabled by default);
</span><span style="font-size: 10pt"><tt>SCHED</tt></span><span style="font-size: 10pt">
re-enables it.
Branch folding, code copying, and dead code elimination are
disabled for instructions that are not scheduled.
</span></p><p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>i960
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Registers are numbered
</span><span style="font-size: 10pt"><tt>R0</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>R31</tt></span><span style="font-size: 10pt">.
Stack pointer is
</span><span style="font-size: 10pt"><tt>R29</tt></span><span style="font-size: 10pt">;
return register is
</span><span style="font-size: 10pt"><tt>R4</tt></span><span style="font-size: 10pt">;
static base is
</span><span style="font-size: 10pt"><tt>R28</tt></span><span style="font-size: 10pt">;
it is initialized to the address of
</span><span style="font-size: 10pt"><tt>setSB(SB)</tt></span><span style="font-size: 10pt">.
</span><span style="font-size: 10pt"><tt>R3</tt></span><span style="font-size: 10pt">
must be zero; this should be done manually early in execution by
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;SUBO&nbsp;&nbsp;&nbsp;&nbsp;R3,&nbsp;R3</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"></span><span style="font-size: 10pt"><tt>R27</tt></span><span style="font-size: 10pt">
is the loader temporary.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">There is no support for floating point.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The Intel calling convention is not supported and cannot be used; use
</span><span style="font-size: 10pt"><tt>BAL</tt></span><span style="font-size: 10pt">
instead.
Instructions are mostly as in the book.  The major change is that
</span><span style="font-size: 10pt"><tt>LOAD</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>STORE</tt></span><span style="font-size: 10pt">
are both called
</span><span style="font-size: 10pt"><tt>MOV</tt></span><span style="font-size: 10pt">.
The extension character for
</span><span style="font-size: 10pt"><tt>MOV</tt></span><span style="font-size: 10pt">
is as in the manual:
</span><span style="font-size: 10pt"><tt>O</tt></span><span style="font-size: 10pt">
for ordinal,
</span><span style="font-size: 10pt"><tt>W</tt></span><span style="font-size: 10pt">
for signed, etc.
</span></p><p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>i386
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The assembler assumes 32-bit protected mode.
The register names are
</span><span style="font-size: 10pt"><tt>SP</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>AX</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>BX</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>CX</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>DX</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>BP</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>DI</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>SI</tt></span><span style="font-size: 10pt">.
The stack pointer (not a pseudo-register) is
</span><span style="font-size: 10pt"><tt>SP</tt></span><span style="font-size: 10pt">
and the return register is
</span><span style="font-size: 10pt"><tt>AX</tt></span><span style="font-size: 10pt">.
There is no physical frame pointer but, as for the MIPS,
</span><span style="font-size: 10pt"><tt>FP</tt></span><span style="font-size: 10pt">
is a pseudo-register that acts as
a frame pointer.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Opcode names are mostly the same as those listed in the Intel manual
with an
</span><span style="font-size: 10pt"><tt>L</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>W</tt></span><span style="font-size: 10pt">,
or
</span><span style="font-size: 10pt"><tt>B</tt></span><span style="font-size: 10pt">
appended to identify 32-bit,
16-bit, and 8-bit operations.
The exceptions are loads, stores, and conditionals.
All load and store opcodes to and from general registers, special registers
(such as
</span><span style="font-size: 10pt"><tt>CR0,</tt></span><span style="font-size: 10pt">
</span><span style="font-size: 10pt"><tt>CR3,</tt></span><span style="font-size: 10pt">
</span><span style="font-size: 10pt"><tt>GDTR,</tt></span><span style="font-size: 10pt">
</span><span style="font-size: 10pt"><tt>IDTR,</tt></span><span style="font-size: 10pt">
</span><span style="font-size: 10pt"><tt>SS,</tt></span><span style="font-size: 10pt">
</span><span style="font-size: 10pt"><tt>CS,</tt></span><span style="font-size: 10pt">
</span><span style="font-size: 10pt"><tt>DS,</tt></span><span style="font-size: 10pt">
</span><span style="font-size: 10pt"><tt>ES,</tt></span><span style="font-size: 10pt">
</span><span style="font-size: 10pt"><tt>FS,</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>GS</tt></span><span style="font-size: 10pt">)
or memory are written
as
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOV</tt></span><span style="font-size: 9pt"><i>x</i></span><span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;src,dst</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">where
</span><span style="font-size: 10pt"><i>x</i></span><span style="font-size: 10pt">
is
</span><span style="font-size: 10pt"><tt>L</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>W</tt></span><span style="font-size: 10pt">,
or
</span><span style="font-size: 10pt"><tt>B</tt></span><span style="font-size: 10pt">.
Thus to get
</span><span style="font-size: 10pt"><tt>AL</tt></span><span style="font-size: 10pt">
use a
</span><span style="font-size: 10pt"><tt>MOVB</tt></span><span style="font-size: 10pt">
instruction.  If you need to access
</span><span style="font-size: 10pt"><tt>AH</tt></span><span style="font-size: 10pt">,
you must mention it explicitly in a
</span><span style="font-size: 10pt"><tt>MOVB</tt></span><span style="font-size: 10pt">:
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVB&nbsp;&nbsp;&nbsp;&nbsp;AH,&nbsp;BX</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">There are many examples of illegal moves, for example,
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVB&nbsp;&nbsp;&nbsp;&nbsp;BP,&nbsp;DI</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">that the loader actually implements as pseudo-operations.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The names of conditions in all conditional instructions
(</span><span style="font-size: 10pt"><tt>J</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>SET</tt></span><span style="font-size: 10pt">)
follow the conventions of the 68020 instead of those of the Intel
assembler:
</span><span style="font-size: 10pt"><tt>JOS</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JOC</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JCS</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JCC</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JEQ</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JNE</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JLS</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JHI</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JMI</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JPL</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JPS</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JPC</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JLT</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JGE</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JLE</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>JGT</tt></span><span style="font-size: 10pt">
instead of
</span><span style="font-size: 10pt"><tt>JO</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JNO</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JB</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JNB</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JZ</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JNZ</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JBE</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JNBE</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JS</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JNS</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JP</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JNP</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JL</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JNL</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>JLE</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>JNLE</tt></span><span style="font-size: 10pt">.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The addressing modes have syntax like
</span><span style="font-size: 10pt"><tt>AX</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>(AX)</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>(AX)(BX*4)</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>10(AX)</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>10(AX)(BX*4)</tt></span><span style="font-size: 10pt">.
The offsets from
</span><span style="font-size: 10pt"><tt>AX</tt></span><span style="font-size: 10pt">
can be replaced by offsets from
</span><span style="font-size: 10pt"><tt>FP</tt></span><span style="font-size: 10pt">
or
</span><span style="font-size: 10pt"><tt>SB</tt></span><span style="font-size: 10pt">
to access names, for example
</span><span style="font-size: 10pt"><tt>extern+5(SB)(AX*2)</tt></span><span style="font-size: 10pt">.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Other notes: Non-relative
</span><span style="font-size: 10pt"><tt>JMP</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>CALL</tt></span><span style="font-size: 10pt">
have a
</span><span style="font-size: 10pt"><tt>*</tt></span><span style="font-size: 10pt">
added to the syntax.
Only
</span><span style="font-size: 10pt"><tt>LOOP</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>LOOPEQ</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>LOOPNE</tt></span><span style="font-size: 10pt">
are legal loop instructions.  Only
</span><span style="font-size: 10pt"><tt>REP</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>REPN</tt></span><span style="font-size: 10pt">
are recognized repeaters.  These are not prefixes, but rather
stand-alone opcodes that precede the strings, for example
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;CLD;&nbsp;REP;&nbsp;MOVSL</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Segment override prefixes in
</span><span style="font-size: 10pt"><tt>MOD/RM</tt></span><span style="font-size: 10pt">
fields are not supported.
</span></p><p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>AMD64
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The assembler assumes 64-bit mode unless a
</span><span style="font-size: 10pt"><tt>MODE</tt></span><span style="font-size: 10pt">
pseudo-operation is given:
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MODE&nbsp;$32</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">to change to 32-bit mode.
The effect is mainly to diagnose instructions that are illegal in
the given mode, but the loader will also assume 32-bit operands and addresses,
and 32-bit PC values for call and return.
The assembler&rsquo;s conventions are similar to those for the 386, above.
The architecture provides extra fixed-point registers
</span><span style="font-size: 10pt"><tt>R8</tt></span><span style="font-size: 10pt">
to
</span><span style="font-size: 10pt"><tt>R15</tt></span><span style="font-size: 10pt">.
All registers are 64 bit, but instructions access low-order 8, 16 and 32 bits
as described in the processor handbook.
For example,
</span><span style="font-size: 10pt"><tt>MOVL</tt></span><span style="font-size: 10pt">
to
</span><span style="font-size: 10pt"><tt>AX</tt></span><span style="font-size: 10pt">
puts a value in the low-order 32 bits and clears the top 32 bits to zero.
Literal operands are limited to signed 32 bit values, which are sign-extended
to 64 bits in 64 bit operations; the exception is
</span><span style="font-size: 10pt"><tt>MOVQ</tt></span><span style="font-size: 10pt">,
which allows 64-bit literals.
The external registers in Plan 9&rsquo;s C are allocated from
</span><span style="font-size: 10pt"><tt>R15</tt></span><span style="font-size: 10pt">
down.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">There are many new instructions, including the MMX and XMM media instructions,
and conditional move instructions.
MMX registers are
</span><span style="font-size: 10pt"><tt>M0</tt></span><span style="font-size: 10pt">
to
</span><span style="font-size: 10pt"><tt>M7</tt></span><span style="font-size: 10pt">,
and
XMM registers are
</span><span style="font-size: 10pt"><tt>X0</tt></span><span style="font-size: 10pt">
to
</span><span style="font-size: 10pt"><tt>X15</tt></span><span style="font-size: 10pt">.
As with the 386 instruction names,
all new 64-bit integer instructions, and the MMX and XMM instructions
uniformly use
</span><span style="font-size: 10pt"><tt>L</tt></span><span style="font-size: 10pt">
for &lsquo;long word&rsquo; (32 bits) and
</span><span style="font-size: 10pt"><tt>Q</tt></span><span style="font-size: 10pt">
for &lsquo;quad word&rsquo; (64 bits).
Some instructions use
</span><span style="font-size: 10pt"><tt>O</tt></span><span style="font-size: 10pt">
(&lsquo;octword&rsquo;) for 128-bit values, where the processor handbook
variously uses
</span><span style="font-size: 10pt"><tt>O</tt></span><span style="font-size: 10pt">
or
</span><span style="font-size: 10pt"><tt>DQ</tt></span><span style="font-size: 10pt">.
The assembler also consistently uses
</span><span style="font-size: 10pt"><tt>PL</tt></span><span style="font-size: 10pt">
for &lsquo;packed long&rsquo; in
XMM instructions, instead of
</span><span style="font-size: 10pt"><tt>Q</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>DQ</tt></span><span style="font-size: 10pt">
or
</span><span style="font-size: 10pt"><tt>PI</tt></span><span style="font-size: 10pt">.
Either
</span><span style="font-size: 10pt"><tt>MOVL</tt></span><span style="font-size: 10pt">
or
</span><span style="font-size: 10pt"><tt>MOVQ</tt></span><span style="font-size: 10pt">
can be used to move values to and from control registers, even when
the registers might be 64 bits.
The assembler often accepts the handbook&rsquo;s name to ease conversion
of existing code (but remember that the operand order is uniformly
source then destination).
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">C&rsquo;s
</span><span style="font-size: 10pt"><tt>long</tt></span><span style="font-size: 10pt">
</span><span style="font-size: 10pt"><tt>long</tt></span><span style="font-size: 10pt">
type is 64 bits, but passed and returned by value, not by reference.
More notably, C pointer values are 64 bits, and thus
</span><span style="font-size: 10pt"><tt>long</tt></span><span style="font-size: 10pt">
</span><span style="font-size: 10pt"><tt>long</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>unsigned</tt></span><span style="font-size: 10pt">
</span><span style="font-size: 10pt"><tt>long</tt></span><span style="font-size: 10pt">
</span><span style="font-size: 10pt"><tt>long</tt></span><span style="font-size: 10pt">
are the only integer types wide enough to hold a pointer value.
The C compiler and library use the XMM floating-point instructions, not
the old 387 ones, although the latter are implemented by assembler and loader.
Unlike the 386, the first integer or pointer argument is passed in a register, which is
</span><span style="font-size: 10pt"><tt>BP</tt></span><span style="font-size: 10pt">
for an integer or pointer (it can be referred to in assembly code by the pseudonym
</span><span style="font-size: 10pt"><tt>RARG</tt></span><span style="font-size: 10pt">).
</span><span style="font-size: 10pt"><tt>AX</tt></span><span style="font-size: 10pt">
holds the return value from subroutines as before.
Floating-point results are returned in
</span><span style="font-size: 10pt"><tt>X0</tt></span><span style="font-size: 10pt">,
although currently the first floating-point parameter is not passed in a register.
All parameters less than 8 bytes in length have 8 byte slots reserved on the stack
to preserve alignment and simplify variable-length argument list access,
including the first parameter when passed in a register,
even though bytes 4 to 7 are not initialized.
</span></p><p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>Power PC
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The Power PC follows the Plan 9 model set by the MIPS and SPARC,
not the elaborate ABIs.
The 32-bit instructions of the 60x and 8xx PowerPC architectures are supported;
there is no support for the older POWER instructions.
Registers are
</span><span style="font-size: 10pt"><tt>R0</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>R31</tt></span><span style="font-size: 10pt">.
</span><span style="font-size: 10pt"><tt>R0</tt></span><span style="font-size: 10pt">
is initialized to zero; this is done by C start up code
and assumed by the compiler and loader.
</span><span style="font-size: 10pt"><tt>R1</tt></span><span style="font-size: 10pt">
is the stack pointer.
</span><span style="font-size: 10pt"><tt>R2</tt></span><span style="font-size: 10pt">
is the static base register, with value the address of
</span><span style="font-size: 10pt"><tt>setSB(SB)</tt></span><span style="font-size: 10pt">.
</span><span style="font-size: 10pt"><tt>R3</tt></span><span style="font-size: 10pt">
is the return register and also the register holding the first
argument to a C function, with space reserved at
</span><span style="font-size: 10pt"><tt>0(FP)</tt></span><span style="font-size: 10pt">
as on the MIPS.
</span><span style="font-size: 10pt"><tt>R31</tt></span><span style="font-size: 10pt">
is the loader temporary.
The external registers in Plan 9&rsquo;s C are allocated from
</span><span style="font-size: 10pt"><tt>R30</tt></span><span style="font-size: 10pt">
down.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Floating point registers are called
</span><span style="font-size: 10pt"><tt>F0</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>F31</tt></span><span style="font-size: 10pt">.
By convention, several registers are initialized
to specific values; this is done by the operating system.
</span><span style="font-size: 10pt"><tt>F27</tt></span><span style="font-size: 10pt">
must be initialized to the value
</span><span style="font-size: 10pt"><tt>0x4330000080000000</tt></span><span style="font-size: 10pt">
(used by float-to-int conversion),
</span><span style="font-size: 10pt"><tt>F28</tt></span><span style="font-size: 10pt">
to the value 0.0,
</span><span style="font-size: 10pt"><tt>F29</tt></span><span style="font-size: 10pt">
to 0.5,
</span><span style="font-size: 10pt"><tt>F30</tt></span><span style="font-size: 10pt">
to 1.0, and
</span><span style="font-size: 10pt"><tt>F31</tt></span><span style="font-size: 10pt">
to 2.0.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">As on the MIPS and SPARC, the assembler accepts arbitrary literals
as operands to
</span><span style="font-size: 10pt"><tt>MOVW</tt></span><span style="font-size: 10pt">,
and also to
</span><span style="font-size: 10pt"><tt>ADD</tt></span><span style="font-size: 10pt">
and others where &lsquo;immediate&rsquo; variants exist,
and the loader generates sequences
of
</span><span style="font-size: 10pt"><tt>addi</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>addis</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>oris</tt></span><span style="font-size: 10pt">,
etc. as required.
The register indirect addressing modes use the same syntax as the SPARC,
including double indexing when allowed.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The instruction names are generally derived from the Motorola ones,
subject to slight transformation:
the
&lsquo;</span><span style="font-size: 10pt"><tt>.</tt></span><span style="font-size: 10pt">&rsquo;
marking the setting of condition codes is replaced by
</span><span style="font-size: 10pt"><tt>CC</tt></span><span style="font-size: 10pt">,
and when the letter
&lsquo;</span><span style="font-size: 10pt"><tt>o</tt></span><span style="font-size: 10pt">&rsquo;
represents &lsquo;OE=1&rsquo; it is replaced by
</span><span style="font-size: 10pt"><tt>V</tt></span><span style="font-size: 10pt">.
Thus
</span><span style="font-size: 10pt"><tt>add</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>addo.</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>subfzeo.</tt></span><span style="font-size: 10pt">
become
</span><span style="font-size: 10pt"><tt>ADD</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>ADDVCC</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>SUBFZEVCC</tt></span><span style="font-size: 10pt">.
As well as the three-operand conditional branch instruction
</span><span style="font-size: 10pt"><tt>BC</tt></span><span style="font-size: 10pt">,
the assembler provides pseudo-instructions for the common cases:
</span><span style="font-size: 10pt"><tt>BEQ</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>BNE</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>BGT</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>BGE</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>BLT</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>BLE</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>BVC</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>BVS</tt></span><span style="font-size: 10pt">.
The unconditional branch instruction is
</span><span style="font-size: 10pt"><tt>BR</tt></span><span style="font-size: 10pt">.
Indirect branches use
</span><span style="font-size: 10pt"><tt>(CTR)</tt></span><span style="font-size: 10pt">
or
</span><span style="font-size: 10pt"><tt>(LR)</tt></span><span style="font-size: 10pt">
as target.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Load or store operations are replaced by
</span><span style="font-size: 10pt"><tt>MOV</tt></span><span style="font-size: 10pt">
variants in the usual way:
</span><span style="font-size: 10pt"><tt>MOVW</tt></span><span style="font-size: 10pt">
(move word),
</span><span style="font-size: 10pt"><tt>MOVH</tt></span><span style="font-size: 10pt">
(move halfword with sign extension), and
</span><span style="font-size: 10pt"><tt>MOVB</tt></span><span style="font-size: 10pt">
(move byte with sign extension, a pseudo-instruction),
with unsigned variants
</span><span style="font-size: 10pt"><tt>MOVHZ</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>MOVBZ</tt></span><span style="font-size: 10pt">,
and byte-reversing
</span><span style="font-size: 10pt"><tt>MOVWBR</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>MOVHBR</tt></span><span style="font-size: 10pt">.
&lsquo;Load or store with update&rsquo; versions are
</span><span style="font-size: 10pt"><tt>MOVWU</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MOVHU</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>MOVBZU</tt></span><span style="font-size: 10pt">.
Load or store multiple is
</span><span style="font-size: 10pt"><tt>MOVMW</tt></span><span style="font-size: 10pt">.
The exceptions are the string instructions, which are
</span><span style="font-size: 10pt"><tt>LSW</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>STSW</tt></span><span style="font-size: 10pt">,
and the reservation instructions
</span><span style="font-size: 10pt"><tt>lwarx</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>stwcx.</tt></span><span style="font-size: 10pt">,
which are
</span><span style="font-size: 10pt"><tt>LWAR</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>STWCCC</tt></span><span style="font-size: 10pt">,
all with operands in the usual data-flow order.
Floating-point load or store instructions are
</span><span style="font-size: 10pt"><tt>FMOVD</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>FMOVDU</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>FMOVS</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>FMOVSU</tt></span><span style="font-size: 10pt">.
The register to register move instructions
</span><span style="font-size: 10pt"><tt>fmr</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>fmr.</tt></span><span style="font-size: 10pt">
are written
</span><span style="font-size: 10pt"><tt>FMOVD</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>FMOVDCC</tt></span><span style="font-size: 10pt">.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The assembler knows the commonly used special purpose registers:
</span><span style="font-size: 10pt"><tt>CR</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>CTR</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>DEC</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>LR</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MSR</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>XER</tt></span><span style="font-size: 10pt">.
The rest, which are often architecture-dependent, are referenced as
</span><span style="font-size: 10pt"><tt>SPR(n)</tt></span><span style="font-size: 10pt">.
The segment registers of the 60x series are similarly
</span><span style="font-size: 10pt"><tt>SEG(n)</tt></span><span style="font-size: 10pt">,
but
</span><span style="font-size: 10pt"><i>n</i></span><span style="font-size: 10pt">
can also be a register name, as in
</span><span style="font-size: 10pt"><tt>SEG(R3)</tt></span><span style="font-size: 10pt">.
Moves between special purpose registers and general purpose ones,
when allowed by the architecture,
are written as
</span><span style="font-size: 10pt"><tt>MOVW</tt></span><span style="font-size: 10pt">,
replacing
</span><span style="font-size: 10pt"><tt>mfcr</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>mtcr</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>mfmsr</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>mtmsr</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>mtspr</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>mfspr</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>mftb</tt></span><span style="font-size: 10pt">,
and many others.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The fields of the condition register
</span><span style="font-size: 10pt"><tt>CR</tt></span><span style="font-size: 10pt">
are referenced as
</span><span style="font-size: 10pt"><tt>CR(0)</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>CR(7)</tt></span><span style="font-size: 10pt">.
They are used by the
</span><span style="font-size: 10pt"><tt>MOVFL</tt></span><span style="font-size: 10pt">
(move field) pseudo-instruction,
which produces
</span><span style="font-size: 10pt"><tt>mcrf</tt></span><span style="font-size: 10pt">
or
</span><span style="font-size: 10pt"><tt>mtcrf</tt></span><span style="font-size: 10pt">.
For example:
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVFL&nbsp;&nbsp;&nbsp;CR(3),&nbsp;CR(0)</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVFL&nbsp;&nbsp;&nbsp;R3,&nbsp;CR(1)</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVFL&nbsp;&nbsp;&nbsp;R3,&nbsp;$7,&nbsp;CR</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">They are also accepted in
the conditional branch instruction, for example
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;BEQ&nbsp;CR(7),&nbsp;label</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Fields of the
</span><span style="font-size: 10pt"><tt>FPSCR</tt></span><span style="font-size: 10pt">
are accessed using
</span><span style="font-size: 10pt"><tt>MOVFL</tt></span><span style="font-size: 10pt">
in a similar way:
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVFL&nbsp;&nbsp;&nbsp;FPSCR,&nbsp;F0</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVFL&nbsp;&nbsp;&nbsp;F0,&nbsp;FPSCR</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVFL&nbsp;&nbsp;&nbsp;F0,&nbsp;$7,&nbsp;FPSCR</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOVFL&nbsp;&nbsp;&nbsp;$0,&nbsp;FPSCR(3)</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">producing
</span><span style="font-size: 10pt"><tt>mffs</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>mtfsf</tt></span><span style="font-size: 10pt">
or
</span><span style="font-size: 10pt"><tt>mtfsfi</tt></span><span style="font-size: 10pt">,
as appropriate.
</span></p><p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>ARM
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The assembler provides access to
</span><span style="font-size: 10pt"><tt>R0</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>R14</tt></span><span style="font-size: 10pt">
and the
</span><span style="font-size: 10pt"><tt>PC</tt></span><span style="font-size: 10pt">.
The stack pointer is
</span><span style="font-size: 10pt"><tt>R13</tt></span><span style="font-size: 10pt">,
the link register is
</span><span style="font-size: 10pt"><tt>R14</tt></span><span style="font-size: 10pt">,
and the static base register is
</span><span style="font-size: 10pt"><tt>R12</tt></span><span style="font-size: 10pt">.
</span><span style="font-size: 10pt"><tt>R0</tt></span><span style="font-size: 10pt">
is the return register and also the register holding
the first argument to a subroutine.
The external registers in Plan 9&rsquo;s C are allocated from
</span><span style="font-size: 10pt"><tt>R10</tt></span><span style="font-size: 10pt">
down.
</span><span style="font-size: 10pt"><tt>R11</tt></span><span style="font-size: 10pt">
is used by the loader as a temporary register.
The assembler supports the
</span><span style="font-size: 10pt"><tt>CPSR</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>SPSR</tt></span><span style="font-size: 10pt">
registers.
It also knows about coprocessor registers
</span><span style="font-size: 10pt"><tt>C0</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>C15</tt></span><span style="font-size: 10pt">.
Floating registers are
</span><span style="font-size: 10pt"><tt>F0</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>F15</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>FPSR</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>FPCR</tt></span><span style="font-size: 10pt">.
Some machines have 32 floating registers, but we ignore them
in the interest of user executable portability, at least for now.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">As with the other architectures, loads and stores are called
</span><span style="font-size: 10pt"><tt>MOV</tt></span><span style="font-size: 10pt">,
e.g.
</span><span style="font-size: 10pt"><tt>MOVW</tt></span><span style="font-size: 10pt">
for load word or store word, and
</span><span style="font-size: 10pt"><tt>MOVM</tt></span><span style="font-size: 10pt">
for
load or store multiple,
depending on the operands.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Addressing modes are supported by suffixes to the instructions:
</span><span style="font-size: 10pt"><tt>.IA</tt></span><span style="font-size: 10pt">
(increment after),
</span><span style="font-size: 10pt"><tt>.IB</tt></span><span style="font-size: 10pt">
(increment before),
</span><span style="font-size: 10pt"><tt>.DA</tt></span><span style="font-size: 10pt">
(decrement after), and
</span><span style="font-size: 10pt"><tt>.DB</tt></span><span style="font-size: 10pt">
(decrement before).
These can only be used with the
</span><span style="font-size: 10pt"><tt>MOV</tt></span><span style="font-size: 10pt">
instructions.
The move multiple instruction,
</span><span style="font-size: 10pt"><tt>MOVM</tt></span><span style="font-size: 10pt">,
defines a range of registers using brackets, e.g.
</span><span style="font-size: 10pt"><tt>[R0-R12]</tt></span><span style="font-size: 10pt">.
The special
</span><span style="font-size: 10pt"><tt>MOVM</tt></span><span style="font-size: 10pt">
addressing mode bits
</span><span style="font-size: 10pt"><tt>W</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>U</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>P</tt></span><span style="font-size: 10pt">
are written in the same manner, for example,
</span><span style="font-size: 10pt"><tt>MOVM.DB.W</tt></span><span style="font-size: 10pt">.
A
</span><span style="font-size: 10pt"><tt>.S</tt></span><span style="font-size: 10pt">
suffix allows a
</span><span style="font-size: 10pt"><tt>MOVM</tt></span><span style="font-size: 10pt">
instruction to access user
</span><span style="font-size: 10pt"><tt>R13</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>R14</tt></span><span style="font-size: 10pt">
when in another processor mode.
Shifts and rotates in addressing modes are supported by binary operators
</span><span style="font-size: 10pt"><tt>&lt;&lt;</tt></span><span style="font-size: 10pt">
(logical left shift),
</span><span style="font-size: 10pt"><tt>&gt;&gt;</tt></span><span style="font-size: 10pt">
(logical right shift),
</span><span style="font-size: 10pt"><tt>-&gt;</tt></span><span style="font-size: 10pt">
(arithmetic right shift), and
</span><span style="font-size: 10pt"><tt>@&gt;</tt></span><span style="font-size: 10pt">
(rotate right); for example
</span><span style="font-size: 10pt"><tt>R7&gt;&gt;R2</tt></span><span style="font-size: 10pt">or
</span><span style="font-size: 10pt"><tt>R2@&gt;2</tt></span><span style="font-size: 10pt">.
The assembler does not support indexing by a shifted expression;
only names can be doubly indexed.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Any instruction can be followed by a suffix that makes the instruction conditional:
</span><span style="font-size: 10pt"><tt>.EQ</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>.NE</tt></span><span style="font-size: 10pt">,
and so on, as in the ARM manual, with synonyms
</span><span style="font-size: 10pt"><tt>.HS</tt></span><span style="font-size: 10pt">
(for
</span><span style="font-size: 10pt"><tt>.CS</tt></span><span style="font-size: 10pt">)
and
</span><span style="font-size: 10pt"><tt>.LO</tt></span><span style="font-size: 10pt">
(for
</span><span style="font-size: 10pt"><tt>.CC</tt></span><span style="font-size: 10pt">),
for example
</span><span style="font-size: 10pt"><tt>ADD.NE</tt></span><span style="font-size: 10pt">.
Arithmetic
and logical instructions
can have a
</span><span style="font-size: 10pt"><tt>.S</tt></span><span style="font-size: 10pt">
suffix, as ARM allows, to set condition codes.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The syntax of the
</span><span style="font-size: 10pt"><tt>MCR</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>MRC</tt></span><span style="font-size: 10pt">
coprocessor instructions is largely as in the manual, with the usual adjustments.
The assembler directly supports only the ARM floating-point coprocessor
operations used by the compiler:
</span><span style="font-size: 10pt"><tt>CMP</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>ADD</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>SUB</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MUL</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>DIV</tt></span><span style="font-size: 10pt">,
all with
</span><span style="font-size: 10pt"><tt>F</tt></span><span style="font-size: 10pt">
or
</span><span style="font-size: 10pt"><tt>D</tt></span><span style="font-size: 10pt">
suffix selecting single or double precision.
Floating-point load or store become
</span><span style="font-size: 10pt"><tt>MOVF</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>MOVD</tt></span><span style="font-size: 10pt">.
Conversion instructions are also specified by moves:
</span><span style="font-size: 10pt"><tt>MOVWD</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MOVWF</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MOVDW</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MOVWD</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MOVFD</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>MOVDF</tt></span><span style="font-size: 10pt">.
</span></p><p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>ARM64
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The assembler provides access to
</span><span style="font-size: 10pt"><tt>R0</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>R31</tt></span><span style="font-size: 10pt">.
The stack pointer is
</span><span style="font-size: 10pt"><tt>R31</tt></span><span style="font-size: 10pt">,
the link register is
</span><span style="font-size: 10pt"><tt>R30</tt></span><span style="font-size: 10pt">,
the frame pointer is
</span><span style="font-size: 10pt"><tt>R29</tt></span><span style="font-size: 10pt">,
and the static base register is
</span><span style="font-size: 10pt"><tt>R28</tt></span><span style="font-size: 10pt">.
</span><span style="font-size: 10pt"><tt>R31</tt></span><span style="font-size: 10pt">
is also
</span><span style="font-size: 10pt"><tt>ZR</tt></span><span style="font-size: 10pt">
(the zero register).
It&rsquo;s the stack pointer when used as base register in load and store
instructions and as source or destination in certain forms of
</span><span style="font-size: 10pt"><tt>ADD</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>SUB</tt></span><span style="font-size: 10pt">
and
&lsquo;logical&rsquo; (boolean) instructions.
</span><span style="font-size: 10pt"><tt>R0</tt></span><span style="font-size: 10pt">
is the return register and also the register holding
the first argument to a subroutine.
The external registers in Plan 9&rsquo;s C are allocated from
</span><span style="font-size: 10pt"><tt>R27</tt></span><span style="font-size: 10pt">
down.
</span><span style="font-size: 10pt"><tt>R17</tt></span><span style="font-size: 10pt">
is used by the loader as a temporary register.
The assembler supports the
</span><span style="font-size: 10pt"><tt>CPSR</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>SPSR</tt></span><span style="font-size: 10pt">
registers.
It also knows about system registers.
Floating registers are
</span><span style="font-size: 10pt"><tt>F0</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>F31</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>FPSR</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>FPCR</tt></span><span style="font-size: 10pt">.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">As with the other architectures, loads and stores are called
</span><span style="font-size: 10pt"><tt>MOV</tt></span><span style="font-size: 10pt">,
e.g.
</span><span style="font-size: 10pt"><tt>MOVW</tt></span><span style="font-size: 10pt">
for load or store 32-bit word,
depending on the operands.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Shifts and rotates in addressing modes are supported by binary operators
</span><span style="font-size: 10pt"><tt>&lt;&lt;</tt></span><span style="font-size: 10pt">
(logical left shift),
</span><span style="font-size: 10pt"><tt>&gt;&gt;</tt></span><span style="font-size: 10pt">
(logical right shift),
</span><span style="font-size: 10pt"><tt>-&gt;</tt></span><span style="font-size: 10pt">
(arithmetic right shift), and
</span><span style="font-size: 10pt"><tt>@&gt;</tt></span><span style="font-size: 10pt">
(rotate right); for example
</span><span style="font-size: 10pt"><tt>R7&gt;&gt;R2</tt></span><span style="font-size: 10pt">or
</span><span style="font-size: 10pt"><tt>R2@&gt;2</tt></span><span style="font-size: 10pt">.
The assembler does not support indexing by a shifted expression;
only names can be doubly indexed.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Arithmetic
and logical instructions
can have an
</span><span style="font-size: 10pt"><tt>S</tt></span><span style="font-size: 10pt">
suffix, as ARM allows, to set condition codes.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The syntax of the
</span><span style="font-size: 10pt"><tt>MSR</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>MRS</tt></span><span style="font-size: 10pt">
system-register instructions is largely as in the manual,
with the usual adjustments.
The assembler directly supports only the ARM floating-point
operations used by the compiler:
</span><span style="font-size: 10pt"><tt>CMP</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>ADD</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>SUB</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MUL</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>DIV</tt></span><span style="font-size: 10pt">,
all with
</span><span style="font-size: 10pt"><tt>F</tt></span><span style="font-size: 10pt">
or
</span><span style="font-size: 10pt"><tt>D</tt></span><span style="font-size: 10pt">
suffix selecting single or double precision.
Floating-point load or store become
</span><span style="font-size: 10pt"><tt>MOVF</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>MOVD</tt></span><span style="font-size: 10pt">.
Conversion instructions are also specified by moves:
</span><span style="font-size: 10pt"><tt>MOVWD</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MOVWF</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MOVDW</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MOVWD</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MOVFD</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>MOVDF</tt></span><span style="font-size: 10pt">.
</span></p><p style="margin-top: 0; margin-bottom: 0.17in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt"><b>RISC-V
</b></span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">There are assemblers for 32-bit and 64-bit RISC-V,
compiled from common source and closely related.
The
</span><span style="font-size: 10pt"><tt>RV32IMAFDC</tt></span><span style="font-size: 10pt">
(a.k.a.,
</span><span style="font-size: 10pt"><tt>RV32GC</tt></span><span style="font-size: 10pt">)
instruction set
(base integer plus multiply and divide, atomics, float, double and compressed)
and RV64GC are supported by the assemblers,
conforming as usual to Plan 9 syntax rather than the form described
in the RISC-V specification.
General-purpose operating systems will generally assume
</span><span style="font-size: 10pt"><tt>RV32G</tt></span><span style="font-size: 10pt">
or
</span><span style="font-size: 10pt"><tt>RV64G</tt></span><span style="font-size: 10pt">.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Registers are
</span><span style="font-size: 10pt"><tt>R0</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>R31</tt></span><span style="font-size: 10pt">,
with
</span><span style="font-size: 10pt"><tt>R1</tt></span><span style="font-size: 10pt">
used as the link register,
</span><span style="font-size: 10pt"><tt>R2</tt></span><span style="font-size: 10pt">
as stack pointer,
</span><span style="font-size: 10pt"><tt>R3</tt></span><span style="font-size: 10pt">
as static base,
</span><span style="font-size: 10pt"><tt>R8</tt></span><span style="font-size: 10pt">
used for the first non-FP function argument and return value, and
</span><span style="font-size: 10pt"><tt>R4</tt></span><span style="font-size: 10pt">
as the loader temporary.
Register external variables are assigned from
</span><span style="font-size: 10pt"><tt>R7</tt></span><span style="font-size: 10pt">
downward.
Note that these register conventions are compatible with the
compressed instruction set extension &mdash; for example, the compressed
form of the
</span><span style="font-size: 10pt"><tt>JAL</tt></span><span style="font-size: 10pt">
instruction assumes that the link register is
</span><span style="font-size: 10pt"><tt>R1</tt></span><span style="font-size: 10pt">.
</span><span style="font-size: 10pt"><tt>FP</tt></span><span style="font-size: 10pt">
is a pseudo-register which denotes the address of the first argument;
</span><span style="font-size: 10pt"><tt>SP</tt></span><span style="font-size: 10pt">
is a pseudo-register which denotes the address at the end of the auto variables.
Both are offsets from
</span><span style="font-size: 10pt"><tt>R2</tt></span><span style="font-size: 10pt">.
Floating registers are
</span><span style="font-size: 10pt"><tt>F0</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>F31</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>CSR(1)</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>CSR(3)</tt></span><span style="font-size: 10pt">.
</span><span style="font-size: 10pt"><tt>F28</tt></span><span style="font-size: 10pt">
through
</span><span style="font-size: 10pt"><tt>F31</tt></span><span style="font-size: 10pt">
are initialised as for the Power PC.
FP arguments are always passed on the stack and FP values are returned in
</span><span style="font-size: 10pt"><tt>F0</tt></span><span style="font-size: 10pt">.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Three-operand logical and arithmetic instructions are written in the order
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;op&nbsp;&nbsp;rs2,&nbsp;rs1,&nbsp;rd</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">where
</span><span style="font-size: 10pt"><i>rs2</i></span><span style="font-size: 10pt">
may be omitted if it&rsquo;s the same as
</span><span style="font-size: 10pt"><i>rd</i></span><span style="font-size: 10pt">.
For all but multiply and divide instructions,
</span><span style="font-size: 10pt"><i>rs2</i></span><span style="font-size: 10pt">
may be replaced by a constant
</span><span style="font-size: 10pt"><i>$con</i></span><span style="font-size: 10pt">
to obtain the immediate form of the instruction (without appending
</span><span style="font-size: 10pt"><tt>I</tt></span><span style="font-size: 10pt">
to the opcode).
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Three-operand conditional branches are written in similar order
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;Bcond&nbsp;&nbsp;&nbsp;rs2,&nbsp;rs1,&nbsp;dest</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">where
</span><span style="font-size: 10pt"><i>rs2</i></span><span style="font-size: 10pt">
may be omitted to indicate comparison with
</span><span style="font-size: 10pt"><tt>R0</tt></span><span style="font-size: 10pt">
(which always contains zero).
For example:
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;SUB&nbsp;R11,&nbsp;R12,&nbsp;R13&nbsp;&nbsp;&nbsp;/*&nbsp;R13&nbsp;=&nbsp;R12&nbsp;-&nbsp;R11&nbsp;*/</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;SUB&nbsp;$1,&nbsp;R12,&nbsp;R13&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;R13&nbsp;=&nbsp;R12&nbsp;-&nbsp;1&nbsp;*/</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;ADD&nbsp;R14,&nbsp;R13&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;R13&nbsp;+=&nbsp;R14&nbsp;*/</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;BLT&nbsp;R11,&nbsp;R13,&nbsp;done&nbsp;&nbsp;/*&nbsp;if&nbsp;(R13&nbsp;&lt;&nbsp;R11)&nbsp;goto&nbsp;done&nbsp;*/</tt></span></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;BNE&nbsp;R11,&nbsp;done&nbsp;&nbsp;&nbsp;/*&nbsp;if&nbsp;(R11&nbsp;!=&nbsp;0)&nbsp;goto&nbsp;done&nbsp;*/</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Mnemonics for conditional branches (some of which are pseudo-ops) are
as in the RISC-V specification:
</span><span style="font-size: 10pt"><tt>BEQ</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>BNE</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>BGT</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>BGE</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>BLT</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>BLE</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>BGTU</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>BGEU</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>BLTU</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>BLEU</tt></span><span style="font-size: 10pt">.
</span><span style="font-size: 10pt"><tt>SLT</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>SLTU</tt></span><span style="font-size: 10pt">
compute the result of a comparison into a register.
Note that the order of comparison operands is reversed relative to what one
might expect (see example above).
The function call instruction
</span><span style="font-size: 10pt"><tt>JAL</tt></span><span style="font-size: 10pt">
takes an explicit link register operand, but the
</span><span style="font-size: 10pt"><tt>RET</tt></span><span style="font-size: 10pt">
pseudo-op assumes the link register is
</span><span style="font-size: 10pt"><tt>R1</tt></span><span style="font-size: 10pt">.
The unconditional branch is
</span><span style="font-size: 10pt"><tt>JMP</tt></span><span style="font-size: 10pt">,
which generates a
</span><span style="font-size: 10pt"><tt>JAL</tt></span><span style="font-size: 10pt">
with
</span><span style="font-size: 10pt"><tt>R0</tt></span><span style="font-size: 10pt">
as the link register.
To branch to an address in a register use
</span><span style="font-size: 10pt"><tt>JMP</tt></span><span style="font-size: 10pt">
with indirect addressing mode,
or
</span><span style="font-size: 10pt"><tt>JAL</tt></span><span style="font-size: 10pt">
for a function call.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">Data movement instructions (loads, stores, and register transfers) all use
</span><span style="font-size: 10pt"><tt>MOV</tt></span><span style="font-size: 10pt">
and variants
</span><span style="font-size: 10pt"><tt>MOVW[U]</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>MOVH[U]</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>MOVB[U]</tt></span><span style="font-size: 10pt">
for register-width data,
[unsigned] 32-bit word, halfword and byte operands.
If
</span><span style="font-size: 10pt"><tt>MOV</tt></span><span style="font-size: 10pt">
is used with a constant source operand to load a value which doesn&rsquo;t
fit into the 12-bit signed immediate field, the loader will generate
</span><span style="font-size: 10pt"><tt>LUI</tt></span><span style="font-size: 10pt">
and
</span><span style="font-size: 10pt"><tt>ADD</tt></span><span style="font-size: 10pt">
instructions as appropriate.
</span></p><p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The
</span><span style="font-size: 10pt"><tt>SYSTEM</tt></span><span style="font-size: 10pt">
instruction is implemented:
</span><span style="font-size: 10pt"><tt>SYS</tt></span><span style="font-size: 10pt">
</span><span style="font-size: 10pt"><tt>$0</tt></span><span style="font-size: 10pt">
is a system call, which expects its number in
</span><span style="font-size: 10pt"><tt>R8</tt></span><span style="font-size: 10pt">
and arguments on the user&rsquo;s stack.
In general,
</span><span style="font-size: 10pt"><tt>SYS</tt></span><span style="font-size: 10pt">
</span><span style="font-size: 10pt"><tt>$</tt></span><span style="font-size: 10pt"></span><span style="font-size: 10pt"><i>n</i></span><span style="font-size: 10pt"></span><span style="font-size: 10pt">
generates a
</span><span style="font-size: 10pt"><tt>SYSTEM</tt></span><span style="font-size: 10pt">
instruction with
</span><span style="font-size: 10pt"><i>n</i></span><span style="font-size: 10pt">
shifted left 20 bits.
CSRs can be accessed simply via
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOV&nbsp;CSR(n),&nbsp;Rd</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">and
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;MOV&nbsp;Rs,&nbsp;CSR(n)</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The more complex swap, set and clear instructions
</span><span style="font-size: 10pt"><tt>CSRRW</tt></span><span style="font-size: 10pt">,
</span><span style="font-size: 10pt"><tt>CSRRS</tt></span><span style="font-size: 10pt">,
and
</span><span style="font-size: 10pt"><tt>CSRRC</tt></span><span style="font-size: 10pt">
are recognised with this syntax:
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;CSRRx&nbsp;&nbsp;CSR(n),&nbsp;Rs,&nbsp;Rd</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">or
</span></p><p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="line-height: 1.1em; margin-left: 1.28in; text-indent: 0.00in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 9pt"><tt>&nbsp;&nbsp;&nbsp;&nbsp;CSRRx&nbsp;&nbsp;CSR(n),&nbsp;$imm,&nbsp;Rd</tt></span></p>
<p style="margin-top: 0; margin-bottom: 0.17in"></p>

<p style="margin-top: 0; margin-bottom: 0.08in"></p>
<p style="margin-top: 0; margin-bottom: 0.05in"></p>
<p style="line-height: 1.2em; margin-left: 1.00in; text-indent: 0.35in; margin-right: 1.00in; margin-top: 0; margin-bottom: 0; text-align: justify;">
<span style="font-size: 10pt">The symbol
</span><span style="font-size: 10pt"><tt>XLEN</tt></span><span style="font-size: 10pt">
is defined by the assembler as the size in bytes of
general registers (and pointers).
</span></p><p style="margin-top: 0; margin-bottom: 0.50in"></p>
</body>
</html>

